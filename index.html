<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Walker Evolution Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background: #1a1a1a; color: #e0e0e0; padding-bottom: 5rem; }
        #main-container { max-width: 1200px; width: 100%; padding: 2rem; box-sizing: border-box; }
        #header { text-align: center; margin-bottom: 1rem; border-bottom: 1px solid #444; padding-bottom: 1rem; }
        h1 { color: #00aaff; margin-bottom: 0.5rem; }
        #header p { color: #b0b0b0; max-width: 800px; margin: 0 auto; line-height: 1.6; }
        .panel { border: 2px solid #444; background: linear-gradient(to bottom, #282c34, #1e2128); border-radius: 8px; overflow: hidden; }
        #simulation-area { position: relative; cursor: grab; margin-bottom: 1rem; }
        #simulation-area:active { cursor: grabbing; }
        .info-panel { position: absolute; top: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 6px; font-size: 14px; z-index: 10; }
        #info { left: 10px; }
        #history-info { right: 10px; text-align: right; }
        .history-entry { color: #ccc; }
        .history-entry span { color: #fff; font-weight: 600; }
        #import-status { text-align: center; color: #00ff88; height: 1em; margin-bottom: 1rem; font-weight: 600; }
        
        #controls-container { display: flex; flex-direction: column; gap: 1rem; }
        #main-actions { padding: 1rem; background-color: #2a2a2a; border-radius: 8px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        #settings-panels { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1rem; }
        
        fieldset { border: 1px solid #444; border-radius: 8px; padding: 1rem; background-color: #2a2a2a; }
        legend { color: #00aaff; font-weight: 600; padding: 0 0.5rem; }
        
        .control-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; align-items: center; }
        .control-group { display: flex; flex-direction: column; align-items: center; cursor: help; text-align: center;}
        .toggle-group { display: flex; align-items: center; justify-content: center; gap: 8px; }
        .radio-group { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;}
        .full-width { grid-column: 1 / -1; }

        label { font-size: 0.9em; margin-bottom: 5px; color: #ccc; }
        input[type="number"] { width: 70px; text-align: center; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; }
        button, .button-label { font-size: 1em; font-weight: 600; padding: 10px 20px; border: none; border-radius: 5px; background: #00aaff; color: #fff; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; display: inline-block; }
        button:hover, .button-label:hover { background: #0088cc; }
        button:disabled { background: #555; opacity: 0.5; cursor: not-allowed; }
        #pauseButton { background-color: #ffaa00; }
        #pauseButton:hover { background-color: #cc8800; }
        #resetButton { background-color: #dd5555; }
        #resetButton:hover { background-color: #bb3333; }
        #exportButton { background-color: #55dd55; }
        #exportButton:hover { background-color: #33bb33; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div id="main-container">
        <div id="header"><h1>AI Walker Evolution Simulator</h1><p>A population of simple "walkers" is created with random DNA. Their goal: travel as far as possible in a fixed time. The most successful walkers from each generation "breed" to create the next, passing on traits with slight mutations. Over time, they evolve effective ways to walk.</p></div>
        <div id="simulation-area" class="panel">
            <canvas id="world"></canvas>
            <div id="info" class="info-panel"><div>Generation: <span id="generation">0</span></div><div>All-Time Best: <span id="best-distance">0.00</span> m</div><div>Time Left: <span id="time-left">0</span> s</div></div>
            <div id="history-info" class="info-panel"><div class="history-entry">Last Gen Best: <span id="history-1-dist">N/A</span> (Gen <span id="history-1-gen">0</span>)</div><div class="history-entry">Prev Gen Best: <span id="history-2-dist">N/A</span> (Gen <span id="history-2-gen">0</span>)</div></div>
        </div>
        <div id="import-status"></div>
        <div id="controls-container">
            <div id="main-actions" class="panel">
                <button id="startButton">Start Evolution</button>
                <button id="pauseButton" disabled>Pause</button>
                <button id="resetButton">Reset Settings</button>
                <button id="exportButton" disabled>Export DNA</button>
                <label for="import-dna-file" class="button-label">Import DNA</label>
                <input type="file" id="import-dna-file" accept=".json" style="display: none;">
            </div>

            <div id="settings-panels">
                <fieldset>
                    <legend>Core Simulation</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The number of walkers created in each generation."><label for="popSize">Population</label><input type="number" id="popSize" value="100" min="10"></div>
                        <div class="control-group" title="The time each generation has to prove its fitness."><label for="genTime">Time per Gen (s)</label><input type="number" id="genTime" value="15" min="5"></div>
                        <div class="control-group" title="Percentage of the top walkers that breed. Lower values are more 'elitist'."><label for="matingPool">Mating Pool (%)</label><input type="number" id="matingPool" value="50" min="1" max="100"></div>
                        <div class="control-group" title="The friction of the ground."><label for="friction">Ground Friction</label><input type="number" id="friction" value="0.8" min="0.1" step="0.1"></div>
                        <div class="control-group" title="The strength of gravity."><label for="gravity">Gravity</label><input type="number" id="gravity" value="1.0" min="0.1" step="0.1"></div>
                        <div class="control-group" title="How many of the current top performers to display."><label for="topNDisplay">Show Top</label><input type="number" id="topNDisplay" value="10" min="1"></div>
                        <div class="toggle-group full-width" title="Toggle whether the camera automatically follows the current leader."><label for="cameraToggle">Auto-Camera</label><input type="checkbox" id="cameraToggle" checked></div>
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Walker Anatomy & Genetics</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The chance for any single gene to mutate."><label for="mutationRate">Mutation Rate (%)</label><input type="number" id="mutationRate" value="5" min="0"></div>
                        <div class="control-group" title="Number of legs on each walker."><label for="numLegs">Number of Legs</label><input type="number" id="numLegs" value="2" min="1" max="2"></div>
                        <div class="control-group full-width" title="Number of segments per leg. More segments allow for more complex movements."><label for="legJoints">Leg Segments (1-3)</label><input type="number" id="legJoints" value="2" min="1" max="3"></div>
                        
                        <div class="toggle-group"><label for="evolveBodyWidth">Evolve Body Width</label><input type="checkbox" id="evolveBodyWidth" checked></div>
                        <div class="toggle-group"><label for="evolveBodyHeight">Evolve Body Height</label><input type="checkbox" id="evolveBodyHeight" checked></div>
                        <div class="toggle-group"><label for="evolveLegLength">Evolve Leg Length</label><input type="checkbox" id="evolveLegLength" checked></div>
                        <div class="toggle-group"><label for="evolveLegWidth">Evolve Leg Width</label><input type="checkbox" id="evolveLegWidth" checked></div>
                        <div class="toggle-group"><label for="evolveLegAnchorX">Evolve Leg X-Pos</label><input type="checkbox" id="evolveLegAnchorX"></div>
                        <div class="toggle-group"><label for="evolveLegAnchorY">Evolve Leg Y-Pos</label><input type="checkbox" id="evolveLegAnchorY"></div>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Locomotion Goal</legend>
                     <div class="radio-group">
                        <div><label><input type="radio" name="locomotion" value="none"> None (Free Evolution)</label></div>
                        <div><label><input type="radio" name="locomotion" value="bipedal" checked> Bipedal (Penalize Falling)</label></div>
                        <div><label><input type="radio" name="locomotion" value="quadrupedal"> Quadrupedal (Penalize being upright)</label></div>
                    </div>
                </fieldset>
            </div>
        </div>

        <div id="chart-container" class="panel" style="margin-top: 2rem; padding: 1rem;">
            <canvas id="evolutionChart"></canvas>
        </div>
    </div>

<script>
const { Engine, Render, Runner, World, Bodies, Body, Constraint, Vector, Events, Composite } = Matter;

// Main elements
const canvas = document.getElementById('world');
const startButton = document.getElementById('startButton'), pauseButton = document.getElementById('pauseButton');
const resetButton = document.getElementById('resetButton'), exportButton = document.getElementById('exportButton');
const importDnaFile = document.getElementById('import-dna-file'), importStatus = document.getElementById('import-status');

// Info displays
const info_gen = document.getElementById('generation'), info_dist = document.getElementById('best-distance'), info_time = document.getElementById('time-left');
const history1DistEl = document.getElementById('history-1-dist'), history1GenEl = document.getElementById('history-1-gen');
const history2DistEl = document.getElementById('history-2-dist'), history2GenEl = document.getElementById('history-2-gen');

// --- Input elements ---
const popSizeInput = document.getElementById('popSize'), genTimeInput = document.getElementById('genTime'), topNDisplayInput = document.getElementById('topNDisplay');
const cameraToggleInput = document.getElementById('cameraToggle'), frictionInput = document.getElementById('friction'), gravityInput = document.getElementById('gravity'); // FIXED: Typo was here!
const mutationRateInput = document.getElementById('mutationRate'), matingPoolInput = document.getElementById('matingPool'), numLegsInput = document.getElementById('numLegs');
const legJointsInput = document.getElementById('legJoints');
const evolveBodyWidthToggle = document.getElementById('evolveBodyWidth'), evolveBodyHeightToggle = document.getElementById('evolveBodyHeight');
const evolveLegLengthToggle = document.getElementById('evolveLegLength'), evolveLegWidthToggle = document.getElementById('evolveLegWidth');
const evolveLegAnchorXToggle = document.getElementById('evolveLegAnchorX'), evolveLegAnchorYToggle = document.getElementById('evolveLegAnchorY'); // New toggles

const SIM_WIDTH = 1200, SIM_HEIGHT = 600, SPAWN_X = 100;

// --- State variables ---
let popSize, mutationRate, topNDisplay, genTime, legSegments, matingPoolPercent, numLegs, gravity, friction;
let evolveBodyW, evolveBodyH, evolveLegL, evolveLegW, evolveLegAnchorX, evolveLegAnchorY, locomotionGoal; // Updated with new toggles
let population = [], historyFlag1 = [], historyFlag2 = [];
let generation = 0, bestDistanceAllTime = 0;
let previousBest1 = { generation: 0, distance: 0 }, previousBest2 = { generation: 0, distance: 0 };
let runner, engine, render, ground;
let generationTimer, uiTimer, isRunning = false, isStarting = false, isPaused = false;
let cameraTargetX = SPAWN_X, cameraX = SPAWN_X;
let isPanning = false, lastPanX = 0;
let evolutionChart, generationHistory = [];
let importedDnaPool = null;
let lastGenerationMatingPool = []; // Stores DNA from the last completed successful generation for export

const defaultSettings = {};
function storeDefaultSettings() {
    document.querySelectorAll('#settings-panels input').forEach(input => {
        const key = input.type === 'radio' ? input.name : input.id;
        if (input.type === 'radio') {
            if (input.checked) defaultSettings[key] = input.value;
        } else {
            defaultSettings[key] = input.type === 'checkbox' ? input.checked : input.value;
        }
    });
}

class Walker {
    constructor(dna, x, y) {
        // console.log(`Walker constructor: Creating walker with DNA:`, dna);
        this.dna = dna;
        const group = -1; // Collide with nothing in the same group
        const bodyRenderStyle = { strokeStyle: '#333', lineWidth: 2 };
        const opt = { friction: 0.8, collisionFilter: { group }, render: bodyRenderStyle };
        this.composite = Composite.create({ label: 'Walker' });

        // Torso creation with bounds checking
        const torsoW = Math.max(10, Math.min(200, dna.genes.torsoSize.w)); // Ensure sensible size
        const torsoH = Math.max(10, Math.min(200, dna.genes.torsoSize.h));
        const torso = Bodies.rectangle(x, y, torsoW, torsoH, {...opt, render: { ...bodyRenderStyle, fillStyle: dna.genes.color }});
        this.torso = torso;
        this.startPosition = Vector.clone(torso.position);
        Composite.addBody(this.composite, torso);
        // console.log(`Torso created: x=${torso.position.x}, y=${torso.position.y}, w=${torsoW}, h=${torsoH}`);

        dna.genes.legs.forEach((legDna, legIndex) => {
            let parentBody = this.torso;
            // Use the evolved leg anchor point from DNA, with a fallback if somehow missing or invalid
            const defaultAnchor = { x:0, y: dna.genes.torsoSize.h / 2 };
            const rawAnchor = dna.genes.legAnchors[legIndex] || defaultAnchor;
            
            // Bounds check for anchor points to prevent extreme values
            const parentAttachPoint = { 
                x: Math.max(-torsoW/2 + 5, Math.min(torsoW/2 - 5, rawAnchor.x)), // Stay within torso width
                y: Math.max(-torsoH/2 + 5, Math.min(torsoH/2 - 5, rawAnchor.y))  // Stay within torso height
            };
            // console.log(`Leg ${legIndex} anchor:`, parentAttachPoint);

            legDna.forEach((segmentDna, segIndex) => {
                const legWidth = Math.max(5, Math.min(30, segmentDna.width)); // Bounds check
                const legLength = Math.max(10, Math.min(100, segmentDna.len)); // Bounds check

                // Position calculations use the parentAttachPoint relative to the parent body's center
                // For the first segment, this is relative to the torso.
                // For subsequent segments, it's relative to the previous segment's center.
                const spawnX = parentBody.position.x + parentAttachPoint.x; 
                const spawnY = parentBody.position.y + parentAttachPoint.y + legLength / 2; 

                const segmentBody = Bodies.rectangle(spawnX, spawnY, legWidth, legLength, {...opt, render: { ...bodyRenderStyle, fillStyle: '#888' }});
                const joint = Constraint.create({
                    bodyA: parentBody, bodyB: segmentBody,
                    pointA: parentAttachPoint, pointB: { x: 0, y: -legLength / 2 },
                    stiffness: 0.9, length: 0, render: { visible: false }
                });
                Composite.addBody(this.composite, segmentBody);
                Composite.addConstraint(this.composite, joint);
                
                // For subsequent segments of the *same* leg, the attachment is relative to the *previous* segment's end
                parentBody = segmentBody;
                parentAttachPoint = { x: 0, y: legLength / 2 }; // This point is now relative to the segment's center
                // console.log(`  Leg ${legIndex}, Segment ${segIndex} created.`);
            });
        });
        World.add(engine.world, this.composite);
        // console.log(`Walker composite added to world. Total bodies in world: ${engine.world.bodies.length}`);
    }
    update(simTime) {
        // Ensure there are actual legs/segments before trying to animate
        if (!this.dna.genes.legs || this.dna.genes.legs.length === 0) return;

        const allSegmentsDna = this.dna.genes.legs.flat();
        // Skip torso (index 0)
        const legSegmentBodies = this.composite.bodies.slice(1); 
        legSegmentBodies.forEach((segmentBody, index) => {
            const segmentDna = allSegmentsDna[index];
            if (segmentDna) {
                Body.setAngularVelocity(segmentBody, Math.sin(simTime * segmentDna.motorSpeed + segmentDna.motorOffset) * segmentDna.motorStrength);
            }
        });
    }
    render(style) { const v = style !== 'hidden'; Composite.allBodies(this.composite).forEach(p => p.render.visible = v); }
    destroy() { World.remove(engine.world, this.composite); }
}
class DNA {
    constructor(genes) {
        if (genes) {
            this.genes = genes;
        } else {
            this.genes = { legs: [], color: `hsl(${Math.random() * 360}, 70%, 70%)` };
            
            // Torso Size (with min/max bounds)
            const baseW = (locomotionGoal === 'quadrupedal') ? 60 : 20;
            const baseH = (locomotionGoal === 'quadrupedal') ? 20 : 40;
            const randW = evolveBodyW ? Math.random() * 30 : 0;
            const randH = evolveBodyH ? Math.random() * 30 : 0;
            this.genes.torsoSize = { 
                w: Math.max(10, Math.min(200, baseW + randW)), // Ensure sensible size
                h: Math.max(10, Math.min(200, baseH + randH))
            };
            
            this.genes.legAnchors = [];
            for (let i = 0; i < numLegs; i++) {
                let baseAnchorX, baseAnchorY;
                const torsoHalfW = this.genes.torsoSize.w / 2;
                const torsoHalfH = this.genes.torsoSize.h / 2;

                // Determine base anchor point based on locomotion goal and number of legs
                if (locomotionGoal === 'quadrupedal') {
                    baseAnchorY = torsoHalfH - 5; // Slightly up from the very bottom for stability
                    if (numLegs === 1) {
                        baseAnchorX = 0;
                    } else { // 2 legs for quadrupedal
                        baseAnchorX = (i === 0) ? -torsoHalfW * 0.75 : torsoHalfW * 0.75; // More towards the ends
                    }
                } else { // Bipedal or None
                    baseAnchorY = torsoHalfH; // Exactly at the bottom for bipedal
                    if (numLegs === 1) {
                        baseAnchorX = 0;
                    } else { // 2 legs for bipedal
                        baseAnchorX = (i === 0) ? -torsoHalfW * 0.5 : torsoHalfW * 0.5; // Balanced left/right
                    }
                }

                // Add random offset if evolution is enabled for anchors, clamp to reasonable range
                const initialAnchorRangeX = 40; // Max random offset for X
                const initialAnchorRangeY = 30; // Max random offset for Y

                const anchorX = evolveLegAnchorX ? baseAnchorX + (Math.random() - 0.5) * initialAnchorRangeX : baseAnchorX;
                const anchorY = evolveLegAnchorY ? baseAnchorY + (Math.random() - 0.5) * initialAnchorRangeY : baseAnchorY;

                // Clamp anchor points to within the torso's approximate boundaries (with a small margin)
                this.genes.legAnchors.push({ 
                    x: Math.max(-torsoHalfW + 5, Math.min(torsoHalfW - 5, anchorX)),
                    y: Math.max(-torsoHalfH + 5, Math.min(torsoHalfH - 5, anchorY))
                });
            }

            // Create leg segments
            for (let i = 0; i < numLegs; i++) {
                const leg = [];
                for (let j = 0; j < legSegments; j++) {
                    const len = evolveLegL ? Math.max(10, Math.min(100, 20 + Math.random() * 40)) : 40;
                    const width = evolveLegW ? Math.max(5, Math.min(30, 5 + Math.random() * 10)) : 10;
                    leg.push({ 
                        len, 
                        width, 
                        motorSpeed: Math.random() * 5, 
                        motorOffset: Math.random() * Math.PI, 
                        motorStrength: Math.random() * 0.5 
                    });
                }
                this.genes.legs.push(leg);
            }
            // console.log("New DNA genes:", this.genes);
        }
    }
    crossover(p) {
        const nG = JSON.parse(JSON.stringify(this.genes));
        if (Math.random() < 0.5) nG.color = p.genes.color;
        if (Math.random() < 0.5) nG.torsoSize = p.genes.torsoSize;
        
        // Crossover leg anchors: Iterating per leg, swap if random condition met
        for (let i = 0; i < numLegs; i++) {
            if (p.genes.legAnchors[i] && Math.random() < 0.5) { // Ensure parent has the anchor
                nG.legAnchors[i] = { ...p.genes.legAnchors[i] };
            }
        }

        for (let legIndex = 0; legIndex < numLegs; legIndex++) {
            for (let segIndex = 0; segIndex < legSegments; segIndex++) {
                const pSeg = p.genes.legs[legIndex]?.[segIndex];
                const cSeg = nG.legs[legIndex]?.[segIndex];
                if(pSeg && cSeg) {
                    if(Math.random()<0.5) cSeg.len = pSeg.len; if(Math.random()<0.5) cSeg.width = pSeg.width;
                    if(Math.random()<0.5) cSeg.motorSpeed = pSeg.motorSpeed; if(Math.random()<0.5) cSeg.motorOffset = pSeg.motorOffset;
                    if(Math.random()<0.5) cSeg.motorStrength = pSeg.motorStrength;
                }
            }
        }
        return new DNA(nG);
    }
    mutate(r) {
        const m = (v, d) => v + (Math.random() - 0.5) * d;
        
        // Torso mutation with bounds
        if (evolveBodyW && Math.random() < r) this.genes.torsoSize.w = Math.max(10, Math.min(200, m(this.genes.torsoSize.w, 10)));
        if (evolveBodyH && Math.random() < r) this.genes.torsoSize.h = Math.max(10, Math.min(200, m(this.genes.torsoSize.h, 10)));
        
        this.genes.legAnchors.forEach(anchor => {
            const torsoHalfW = this.genes.torsoSize.w / 2;
            const torsoHalfH = this.genes.torsoSize.h / 2;
            
            // Mutate X anchor if enabled, clamp within torso bounds
            if (evolveLegAnchorX && Math.random() < r) {
                anchor.x = Math.max(-torsoHalfW + 5, Math.min(torsoHalfW - 5, m(anchor.x, 15)));
            }
            // Mutate Y anchor if enabled, clamp within torso bounds
            if (evolveLegAnchorY && Math.random() < r) {
                anchor.y = Math.max(-torsoHalfH + 5, Math.min(torsoHalfH - 5, m(anchor.y, 10)));
            }
        });

        this.genes.legs.forEach(leg => {
            leg.forEach(segment => {
                if (evolveLegL && Math.random() < r) segment.len = Math.max(10, Math.min(100, m(segment.len, 10)));
                if (evolveLegW && Math.random() < r) segment.width = Math.max(5, Math.min(30, m(segment.width, 5)));
                if (Math.random() < r) segment.motorSpeed = m(segment.motorSpeed, 1);
                if (Math.random() < r) segment.motorOffset = m(segment.motorOffset, Math.PI / 2);
                if (Math.random() < r) segment.motorStrength = m(segment.motorStrength, 0.1);
            });
        });
        if (Math.random() < r) this.genes.color = `hsl(${Math.random() * 360}, 70%, 70%)`;
    }
}

function setup() {
    console.log("setup() called. Initializing Matter.js engine and renderer...");
    engine = Engine.create({ positionIterations: 4, velocityIterations: 2 }); 
    engine.world.gravity.y = gravity;
    render = Render.create({canvas:canvas,engine:engine,options:{width:SIM_WIDTH,height:SIM_HEIGHT,wireframes:false,background:'transparent'}});
    
    // Check if gravity is a valid number
    if (isNaN(engine.world.gravity.y) || !isFinite(engine.world.gravity.y)) {
        console.error("Invalid gravity value:", gravity, ". Setting to default 1.0.");
        engine.world.gravity.y = 1.0;
    }

    ground = Bodies.rectangle(SIM_WIDTH*2, SIM_HEIGHT-25, SIM_WIDTH*10, 50, {isStatic:true, friction: friction, render:{fillStyle:'#333'}});
    World.add(engine.world, [ground, ...createFlag(SPAWN_X, '#00dd00')]);
    console.log("Ground and initial flag added to world.");

    Events.on(engine, 'beforeUpdate', () => { 
        if (isRunning && !isPaused) {
            population.forEach(walker => walker.update(engine.timing.timestamp / 1000)); 
        }
    });
    Runner.run(runner, engine); 
    Render.run(render);
    console.log("Matter.js Runner and Renderer started.");
    nextGeneration();
}

function uiLoop() {
    if (isStarting || (!isRunning && !isPaused)) return;
    if(!isPaused) {
        updateDisplayAndCamera();
        const timeLeft = genTime - (performance.now() - generationTimer) / 1000;
        info_time.textContent = Math.max(0, timeLeft).toFixed(1);
        if (timeLeft <= 0) nextGeneration();
    }
    if (isRunning) uiTimer = requestAnimationFrame(uiLoop);
}

function updateDisplayAndCamera() {
    if (population.length === 0) return; // Prevent errors if population is empty
    population.sort((a,b) => b.torso.position.x - a.torso.position.x);
    const topPerformers = new Set(population.slice(0, topNDisplay));
    population.forEach(w => w.render(topPerformers.has(w)?'normal':'hidden'));
    if (cameraToggleInput.checked && population.length > 0) cameraTargetX = population[0].torso.position.x;
    cameraX += (cameraTargetX - cameraX) * 0.05;
    Render.lookAt(render, {min:{x:cameraX - SIM_WIDTH/2, y:0}, max:{x:cameraX + SIM_WIDTH/2, y:SIM_HEIGHT}});
}

function nextGeneration() {
    console.log(`--- Starting Generation ${generation + 1} ---`);
    isRunning = false;
    if(uiTimer) cancelAnimationFrame(uiTimer);

    // 1. Calculate fitness for the *current (just finished)* population
    population.forEach(w => {
        let distance = Math.max(0, w.torso.position.x - w.startPosition.x);
        const torsoAngle = w.torso.angle;

        if (locomotionGoal === 'bipedal') {
            const uprightAngleThreshold = Math.PI / 3;
            if (Math.abs(torsoAngle) > uprightAngleThreshold) distance *= 0.1;
        } else if (locomotionGoal === 'quadrupedal') {
            const horizontalAngleThreshold = Math.PI / 4;
            // If the walker is too upright (not horizontal enough) for quadrupedal, penalize
            if (Math.abs(Math.abs(torsoAngle) - Math.PI/2) > horizontalAngleThreshold) distance *= 0.1;
        }
        w.fitness = distance;
    });

    // 2. Sort the *current (just finished)* population by fitness
    population.sort((a, b) => b.fitness - a.fitness);
    
    const bestWalker = population.length > 0 ? population[0] : null;
    const bestDist = bestWalker ? bestWalker.fitness : 0;
    
    // Store the mating pool from THIS completed generation for export and next breeding
    lastGenerationMatingPool = []; // Clear it first
    const eliteCountForExport = Math.floor(population.length * (matingPoolPercent / 100));
    if(population.length > 0 && population[0].fitness > 0) { // Only store if there was actual forward movement
        const eliteForExport = population.slice(0, Math.max(1, eliteCountForExport));
        eliteForExport.forEach(w => { 
            for(let i=0; i<100; i++) lastGenerationMatingPool.push(w.dna); 
        });
    }
    console.log(`Generation ${generation} best distance: ${bestDist.toFixed(2)}m. Mating pool size: ${lastGenerationMatingPool.length}`);


    if (generation > 0) generationHistory.push({ generation: generation, distance: bestWalker ? Math.max(0, bestWalker.torso.position.x - bestWalker.startPosition.x) : 0 });
    if (bestDist > bestDistanceAllTime) bestDistanceAllTime = bestDist;
    if (generation > 0) { previousBest2 = {...previousBest1}; previousBest1 = {generation: generation, distance: bestDist}; }

    generation++; info_gen.textContent = generation; info_dist.textContent = bestDistanceAllTime.toFixed(2);
    updateHistoryUIAndFlags(); updateChart();
    
    // Determine the mating pool for the *NEXT* generation.
    let matingPoolForBreeding;
    if (generation === 1 && importedDnaPool) { // For the very first generation (Gen 1)
        matingPoolForBreeding = importedDnaPool;
        importedDnaPool = null; // Use imported DNA only once
        importStatus.textContent = '';
        console.log("Using imported DNA for breeding pool.");
    } else { // For subsequent generations, use the just-calculated `lastGenerationMatingPool`
        matingPoolForBreeding = lastGenerationMatingPool;
        console.log("Using previous generation's mating pool for breeding.");
    }

    population.forEach(w => w.destroy()); population = []; // Clear old population
    const spawnPromises = [];
    for (let i = 0; i < popSize; i++) {
        const spawnPromise = new Promise(resolve => setTimeout(() => {
            if (isStarting) return resolve(); // If simulation reset/stopped mid-spawn
            try {
                // Pick DNA from `matingPoolForBreeding` or create new if pool is empty
                const pA = matingPoolForBreeding.length > 0 ? matingPoolForBreeding[Math.floor(Math.random()*matingPoolForBreeding.length)] : new DNA();
                const pB = matingPoolForBreeding.length > 0 ? matingPoolForBreeding[Math.floor(Math.random()*matingPoolForBreeding.length)] : new DNA();
                const childDNA = pA.crossover(pB); childDNA.mutate(mutationRate);
                
                // Spawn height adjustment to ensure they are above ground
                const spawnHeight = SIM_HEIGHT - 100; // General safe spawn height
                // If bipedal, potentially higher for a "drop"
                if (locomotionGoal === 'bipedal') {
                    spawnHeight = SIM_HEIGHT - 250; 
                }

                population.push(new Walker(childDNA, SPAWN_X, spawnHeight));
                // console.log(`Spawned Walker ${i + 1}/${popSize}`);
            } catch (e) {
                console.error(`Error spawning walker ${i + 1}:`, e);
                // Continue trying to spawn others, but log the error
            }
            resolve();
        }, i * (500 / popSize) )); // Stagger spawning slightly for large populations
        spawnPromises.push(spawnPromise); 
    }
    
    Promise.all(spawnPromises).then(() => { 
        if (!isStarting) { 
            isRunning = true; 
            isPaused = false; 
            generationTimer = performance.now(); 
            uiTimer = requestAnimationFrame(uiLoop); 
            console.log(`Generation ${generation} spawned. Simulation running.`);
        } else {
            console.log("Spawn sequence interrupted due to simulation restart.");
        }
    }).catch(e => {
        console.error("Error during walker spawning promise resolution:", e);
    });
}

function createFlag(x, color) { const y = SIM_HEIGHT-50, opt={isStatic:true,isSensor:true,render:{fillStyle:color}}; return [Bodies.rectangle(x, y-20, 3, 40, opt), Bodies.rectangle(x+10, y-40, 20, 10, opt)]; }
function updateHistoryUIAndFlags() {
    if(historyFlag1.length>0)World.remove(engine.world,historyFlag1); if(historyFlag2.length>0)World.remove(engine.world,historyFlag2);
    historyFlag1=[],historyFlag2=[];
    if(previousBest1.generation>0){ history1DistEl.textContent=`${previousBest1.distance.toFixed(2)}m`;history1GenEl.textContent=previousBest1.generation; if(previousBest1.distance>0){historyFlag1=createFlag(SPAWN_X+previousBest1.distance,'#ffd700');World.add(engine.world,historyFlag1);}}else{history1DistEl.textContent="N/A";history1GenEl.textContent="0";}
    if(previousBest2.generation>0){ history2DistEl.textContent=`${previousBest2.distance.toFixed(2)}m`;history2GenEl.textContent=previousBest2.generation; if(previousBest2.distance>0){historyFlag2=createFlag(SPAWN_X+previousBest2.distance,'#00aaff');World.add(engine.world,historyFlag2);}}else{history2DistEl.textContent="N/A";history2GenEl.textContent="0";}
}

function setupChart() {
    const ctx = document.getElementById('evolutionChart').getContext('2d');
    evolutionChart = new Chart(ctx, {
        type: 'line', data: { labels: [], datasets: [{ label: 'Best Distance per Generation', data: [], borderColor: '#00aaff', backgroundColor: 'rgba(0, 170, 255, 0.2)', borderWidth: 2, fill: true, tension: 0.1 }] },
        options: { scales: { x: { title: { display: true, text: 'Generation', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} }, y: { title: { display: true, text: 'Distance (m)', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} } }, plugins: { legend: { labels: { color: '#ccc' } } }, responsive: true, }
    });
}
function updateChart() {
    if (!evolutionChart) return;
    evolutionChart.data.labels = generationHistory.map(h => h.generation);
    evolutionChart.data.datasets[0].data = generationHistory.map(h => h.distance);
    evolutionChart.update();
}

function readSettings() { 
    popSize = parseInt(popSizeInput.value); 
    mutationRate = parseFloat(mutationRateInput.value)/100;
    topNDisplay = parseInt(topNDisplayInput.value); 
    genTime = parseInt(genTimeInput.value);
    legSegments = Math.max(1,Math.min(3,parseInt(legJointsInput.value))); legJointsInput.value = legSegments; // Clamp and update input
    matingPoolPercent = parseInt(matingPoolInput.value); 
    numLegs = parseInt(numLegsInput.value);
    gravity = parseFloat(gravityInput.value); 
    friction = parseFloat(frictionInput.value);
    evolveBodyW = evolveBodyWidthToggle.checked; 
    evolveBodyH = evolveBodyHeightToggle.checked;
    evolveLegL = evolveLegLengthToggle.checked; 
    evolveLegW = evolveLegWidthToggle.checked;
    evolveLegAnchorX = evolveLegAnchorXToggle.checked; 
    evolveLegAnchorY = evolveLegAnchorYToggle.checked; 
    locomotionGoal = document.querySelector('input[name="locomotion"]:checked').value;
    console.log("Settings read:", {popSize, mutationRate, genTime, numLegs, legSegments, gravity, friction, evolveLegAnchorX, evolveLegAnchorY, locomotionGoal});
}

// --- Event Listeners ---
resetButton.addEventListener('click', () => {
    Object.entries(defaultSettings).forEach(([key, value]) => {
        if (key === 'locomotion') {
            document.querySelector(`input[name="locomotion"][value="${value}"]`).checked = true;
        } else {
            const input = document.getElementById(key);
            if (input.type === 'checkbox') input.checked = value;
            else input.value = value;
        }
    });
    readSettings(); // Re-read settings after reset
    console.log("Settings reset to defaults.");
});
pauseButton.addEventListener('click', () => {
    if (!isRunning) return;
    isPaused = !isPaused;
    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
    console.log(`Simulation ${isPaused ? 'paused' : 'resumed'}.`);
    if (!isPaused) {
        generationTimer += performance.now() - (window.pauseStartTime || 0);
        uiLoop();
    } else {
        window.pauseStartTime = performance.now();
    }
});
function stopSimulation() {
    console.log("Stopping simulation components.");
    isRunning = false; isPaused = false;
    if (uiTimer) cancelAnimationFrame(uiTimer);
    if (runner) Runner.stop(runner);
    if (render) Render.stop(render);
    if (engine) { 
        World.clear(engine.world); 
        Engine.clear(engine); 
        // Reset engine to default state for re-use, though recreating might be safer
        engine = null; 
        render = null;
        runner = null;
    }
}
startButton.addEventListener('click', () => {
    if (isStarting) return;
    console.log("Start Evolution button clicked.");
    isStarting = true;
    startButton.textContent = 'Starting...'; startButton.disabled = true;
    pauseButton.disabled = true; pauseButton.textContent = 'Pause';
    exportButton.disabled = true;
    
    stopSimulation(); // Ensure previous simulation is cleanly stopped
    
    // Give a small delay to ensure cleanup before new setup
    setTimeout(() => {
        readSettings(); // Read current settings before starting new sim
        generation = 0; bestDistanceAllTime = 0; population = [];
        previousBest1 = { generation: 0, distance: 0 }; previousBest2 = { generation: 0, distance: 0 };
        generationHistory = []; cameraX = SPAWN_X; cameraTargetX = SPAWN_X;
        lastGenerationMatingPool = []; // Reset the exportable DNA pool on new start
        
        updateHistoryUIAndFlags();
        if (evolutionChart) { evolutionChart.data.labels = []; evolutionChart.data.datasets[0].data = []; evolutionChart.update(); }
        
        setup(); // Re-initialize Matter.js and start first generation
        
        isStarting = false;
        startButton.textContent = 'Restart Evolution'; startButton.disabled = false;
        pauseButton.disabled = false; exportButton.disabled = false;
        console.log("Simulation setup complete and running.");
    }, 100);
});
exportButton.addEventListener('click', () => {
    if (!lastGenerationMatingPool || lastGenerationMatingPool.length === 0) {
        alert("No successful walkers (i.e., none moved forward) to export yet. Let at least one generation complete and achieve some distance.");
        return;
    }
    const dnaJson = JSON.stringify(lastGenerationMatingPool, null, 2); 
    const blob = new Blob([dnaJson], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `walker_dna_gen_${generation - 1}.json`; 
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log(`Exported DNA from generation ${generation - 1}.`);
});
importDnaFile.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importedData = JSON.parse(e.target.result);
            if (Array.isArray(importedData) && importedData.length > 0 && importedData[0] && importedData[0].genes) {
                importedDnaPool = importedData;
                importStatus.textContent = `DNA from "${file.name}" imported successfully! Click Start to use it.`;
                console.log(`Successfully imported DNA from "${file.name}".`);
            } else {
                throw new Error("Invalid DNA file format. Expected an array of DNA objects with 'genes'.");
            }
        } catch (error) {
            alert(`Error reading file: ${error.message}`);
            importedDnaPool = null;
            importStatus.textContent = ''; 
            console.error(`Failed to import DNA from "${file.name}":`, error);
        }
    };
    reader.readAsText(file);
    importDnaFile.value = ''; 
});

// Initial Setup when page loads
storeDefaultSettings();
readSettings();
setupChart();
info_gen.textContent="0";info_dist.textContent="0.00";info_time.textContent=genTimeInput.value;
console.log("Initial page load: Default settings stored, UI updated.");
</script>
</body>
</html>
