<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Walker Evolution Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background: #1a1a1a; color: #e0e0e0; padding-bottom: 5rem; }
        #main-container { max-width: 1200px; width: 100%; padding: 2rem; box-sizing: border-box; }
        #header { text-align: center; margin-bottom: 2rem; border-bottom: 1px solid #444; padding-bottom: 1rem; }
        h1 { color: #00aaff; margin-bottom: 0.5rem; }
        #header p { color: #b0b0b0; max-width: 800px; margin: 0 auto; line-height: 1.6; }
        .panel { border: 2px solid #444; background: linear-gradient(to bottom, #282c34, #1e2128); border-radius: 8px; overflow: hidden; }
        #simulation-area { position: relative; cursor: grab; margin-bottom: 1rem; }
        #simulation-area:active { cursor: grabbing; }
        .info-panel { position: absolute; top: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 6px; font-size: 14px; z-index: 10; }
        #info { left: 10px; }
        #history-info { right: 10px; text-align: right; }
        .history-entry { color: #ccc; }
        .history-entry span { color: #fff; font-weight: 600; }
        
        #controls-container { display: flex; flex-direction: column; gap: 1rem; }
        #main-actions { padding: 1rem; background-color: #2a2a2a; border-radius: 8px; display: flex; justify-content: center; align-items: center; gap: 20px; }
        #settings-panels { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1rem; }
        
        fieldset { border: 1px solid #444; border-radius: 8px; padding: 1rem; background-color: #2a2a2a; }
        legend { color: #00aaff; font-weight: 600; padding: 0 0.5rem; }
        
        .control-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; align-items: center; }
        .control-group { display: flex; flex-direction: column; align-items: center; cursor: help; text-align: center;}
        .toggle-group { display: flex; align-items: center; justify-content: center; gap: 8px; }
        .radio-group { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;}
        .full-width { grid-column: 1 / -1; }

        label { font-size: 0.9em; margin-bottom: 5px; color: #ccc; }
        input[type="number"] { width: 70px; text-align: center; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; }
        button { font-size: 1em; font-weight: 600; padding: 10px 20px; border: none; border-radius: 5px; background: #00aaff; color: #fff; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; }
        button:hover { background: #0088cc; }
        button:disabled { background: #555; opacity: 0.5; cursor: not-allowed; }
        #pauseButton { background-color: #ffaa00; }
        #pauseButton:hover { background-color: #cc8800; }
        #resetButton { background-color: #dd5555; }
        #resetButton:hover { background-color: #bb3333; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div id="main-container">
        <div id="header"><h1>AI Walker Evolution Simulator</h1><p>A population of simple "walkers" is created with random DNA. Their goal: travel as far as possible in a fixed time. The most successful walkers from each generation "breed" to create the next, passing on traits with slight mutations. Over time, they evolve effective ways to walk.</p></div>
        <div id="simulation-area" class="panel">
            <canvas id="world"></canvas>
            <div id="info" class="info-panel"><div>Generation: <span id="generation">0</span></div><div>All-Time Best: <span id="best-distance">0.00</span> m</div><div>Time Left: <span id="time-left">0</span> s</div></div>
            <div id="history-info" class="info-panel"><div class="history-entry">Last Gen Best: <span id="history-1-dist">N/A</span> (Gen <span id="history-1-gen">0</span>)</div><div class="history-entry">Prev Gen Best: <span id="history-2-dist">N/A</span> (Gen <span id="history-2-gen">0</span>)</div></div>
        </div>
        
        <div id="controls-container">
            <div id="main-actions" class="panel">
                <button id="startButton">Start Evolution</button>
                <button id="pauseButton" disabled>Pause</button>
                <button id="resetButton">Reset Settings</button>
            </div>

            <div id="settings-panels">
                <fieldset>
                    <legend>Core Simulation</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The number of walkers created in each generation."><label for="popSize">Population</label><input type="number" id="popSize" value="100" min="10"></div>
                        <div class="control-group" title="The time each generation has to prove its fitness."><label for="genTime">Time per Gen (s)</label><input type="number" id="genTime" value="15" min="5"></div>
                        <div class="control-group" title="Percentage of the top walkers that breed. Lower values are more 'elitist'."><label for="matingPool">Mating Pool (%)</label><input type="number" id="matingPool" value="50" min="1" max="100"></div>
                        <div class="control-group" title="The friction of the ground."><label for="friction">Ground Friction</label><input type="number" id="friction" value="0.8" min="0.1" step="0.1"></div>
                        <div class="control-group" title="The strength of gravity."><label for="gravity">Gravity</label><input type="number" id="gravity" value="1.0" min="0.1" step="0.1"></div>
                        <div class="control-group" title="How many of the current top performers to display."><label for="topNDisplay">Show Top</label><input type="number" id="topNDisplay" value="10" min="1"></div>
                        <div class="toggle-group full-width" title="Toggle whether the camera automatically follows the current leader."><label for="cameraToggle">Auto-Camera</label><input type="checkbox" id="cameraToggle" checked></div>
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Walker Anatomy & Genetics</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The chance for any single gene to mutate."><label for="mutationRate">Mutation Rate (%)</label><input type="number" id="mutationRate" value="5" min="0"></div>
                        <div class="control-group" title="Number of legs on each walker."><label for="numLegs">Number of Legs</label><input type="number" id="numLegs" value="2" min="1" max="2"></div>
                        <div class="control-group full-width" title="Number of segments per leg. More segments allow for more complex movements."><label for="legJoints">Leg Segments (1-3)</label><input type="number" id="legJoints" value="2" min="1" max="3"></div>
                        
                        <div class="toggle-group"><label for="evolveBodyWidth">Evolve Body Width</label><input type="checkbox" id="evolveBodyWidth" checked></div>
                        <div class="toggle-group"><label for="evolveBodyHeight">Evolve Body Height</label><input type="checkbox" id="evolveBodyHeight" checked></div>
                        <div class="toggle-group"><label for="evolveLegLength">Evolve Leg Length</label><input type="checkbox" id="evolveLegLength" checked></div>
                        <div class="toggle-group"><label for="evolveLegWidth">Evolve Leg Width</label><input type="checkbox" id="evolveLegWidth" checked></div>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Locomotion Goal</legend>
                     <div class="radio-group">
                        <div><label><input type="radio" name="locomotion" value="none"> None (Free Evolution)</label></div>
                        <div><label><input type="radio" name="locomotion" value="bipedal" checked> Bipedal (Penalize Falling)</label></div>
                        <div><label><input type="radio" name="locomotion" value="quadrupedal"> Quadrupedal (Penalize being upright)</label></div>
                    </div>
                </fieldset>
            </div>
        </div>

        <div id="chart-container" class="panel" style="margin-top: 2rem; padding: 1rem;">
            <canvas id="evolutionChart"></canvas>
        </div>
    </div>

<script>
const { Engine, Render, Runner, World, Bodies, Body, Constraint, Vector, Events, Composite } = Matter;

// Main elements
const canvas = document.getElementById('world');
const startButton = document.getElementById('startButton'), pauseButton = document.getElementById('pauseButton'), resetButton = document.getElementById('resetButton');

// Info displays
const info_gen = document.getElementById('generation'), info_dist = document.getElementById('best-distance'), info_time = document.getElementById('time-left');
const history1DistEl = document.getElementById('history-1-dist'), history1GenEl = document.getElementById('history-1-gen');
const history2DistEl = document.getElementById('history-2-dist'), history2GenEl = document.getElementById('history-2-gen');

// --- Input elements ---
const popSizeInput = document.getElementById('popSize'), genTimeInput = document.getElementById('genTime'), topNDisplayInput = document.getElementById('topNDisplay');
const cameraToggleInput = document.getElementById('cameraToggle'), frictionInput = document.getElementById('friction'), gravityInput = document.getElementById('gravity');
const mutationRateInput = document.getElementById('mutationRate'), matingPoolInput = document.getElementById('matingPool'), numLegsInput = document.getElementById('numLegs');
const legJointsInput = document.getElementById('legJoints');
const evolveBodyWidthToggle = document.getElementById('evolveBodyWidth'), evolveBodyHeightToggle = document.getElementById('evolveBodyHeight');
const evolveLegLengthToggle = document.getElementById('evolveLegLength'), evolveLegWidthToggle = document.getElementById('evolveLegWidth');

const SIM_WIDTH = 1200, SIM_HEIGHT = 600, SPAWN_X = 100;

// --- State variables ---
let popSize, mutationRate, topNDisplay, genTime, legSegments, matingPoolPercent, numLegs, gravity, friction;
let evolveBodyW, evolveBodyH, evolveLegL, evolveLegW, locomotionGoal;
let population = [], historyFlag1 = [], historyFlag2 = [];
let generation = 0, bestDistanceAllTime = 0;
let previousBest1 = { generation: 0, distance: 0 }, previousBest2 = { generation: 0, distance: 0 };
let runner, engine, render, ground;
let generationTimer, uiTimer, isRunning = false, isStarting = false, isPaused = false;
let cameraTargetX = SPAWN_X, cameraX = SPAWN_X;
let isPanning = false, lastPanX = 0;
let evolutionChart, generationHistory = [];

const defaultSettings = {};
function storeDefaultSettings() {
    document.querySelectorAll('#settings-panels input').forEach(input => {
        const key = input.type === 'radio' ? input.name : input.id;
        if (input.type === 'radio') {
            if (input.checked) defaultSettings[key] = input.value;
        } else {
            defaultSettings[key] = input.type === 'checkbox' ? input.checked : input.value;
        }
    });
}

class Walker {
    constructor(dna, x, y) {
        this.dna = dna;
        const group = -1;
        const bodyRenderStyle = { strokeStyle: '#333', lineWidth: 2 };
        const opt = { friction: 0.8, collisionFilter: { group }, render: bodyRenderStyle };
        this.composite = Composite.create({ label: 'Walker' });
        const torso = Bodies.rectangle(x, y, dna.genes.torsoSize.w, dna.genes.torsoSize.h, {...opt, render: { ...bodyRenderStyle, fillStyle: dna.genes.color }});
        this.torso = torso;
        this.startPosition = Vector.clone(torso.position);
        Composite.addBody(this.composite, torso);

        dna.genes.legs.forEach((legDna, legIndex) => {
            let parentBody = this.torso;
            let parentAttachPoint = { ...dna.genes.legAnchors[legIndex] };
            
            legDna.forEach((segmentDna) => {
                const legWidth = segmentDna.width;
                const legLength = segmentDna.len;
                const spawnX = x + parentAttachPoint.x;
                const spawnY = y + parentAttachPoint.y + legLength / 2;

                const segmentBody = Bodies.rectangle(spawnX, spawnY, legWidth, legLength, {...opt, render: { ...bodyRenderStyle, fillStyle: '#888' }});
                const joint = Constraint.create({
                    bodyA: parentBody, bodyB: segmentBody,
                    pointA: parentAttachPoint, pointB: { x: 0, y: -legLength / 2 },
                    stiffness: 0.9, length: 0, render: { visible: false }
                });
                Composite.addBody(this.composite, segmentBody);
                Composite.addConstraint(this.composite, joint);
                
                parentBody = segmentBody;
                parentAttachPoint = { x: 0, y: legLength / 2 };
            });
        });
        World.add(engine.world, this.composite);
    }
    update(simTime) {
        const allSegmentsDna = this.dna.genes.legs.flat();
        const legSegmentBodies = this.composite.bodies.slice(1);
        legSegmentBodies.forEach((segmentBody, index) => {
            const segmentDna = allSegmentsDna[index];
            if (segmentDna) {
                Body.setAngularVelocity(segmentBody, Math.sin(simTime * segmentDna.motorSpeed + segmentDna.motorOffset) * segmentDna.motorStrength);
            }
        });
    }
    render(style) { const v = style !== 'hidden'; Composite.allBodies(this.composite).forEach(p => p.render.visible = v); }
    destroy() { World.remove(engine.world, this.composite); }
}
class DNA {
    constructor(genes) {
        if (genes) {
            this.genes = genes;
        } else {
            this.genes = { legs: [], color: `hsl(${Math.random() * 360}, 70%, 70%)` };
            
            const baseW = (locomotionGoal === 'quadrupedal') ? 60 : 20;
            const baseH = (locomotionGoal === 'quadrupedal') ? 20 : 40;
            const randW = evolveBodyW ? Math.random() * 30 : 0;
            const randH = evolveBodyH ? Math.random() * 30 : 0;
            this.genes.torsoSize = { w: baseW + randW, h: baseH + randH };
            
            if (locomotionGoal === 'quadrupedal') {
                this.genes.legAnchors = numLegs === 1 ? [{x: 0, y: 0}] : [{ x: -this.genes.torsoSize.w / 2 + 15, y: 0 }, { x: this.genes.torsoSize.w / 2 - 15, y: 0 }];
            } else { // Bipedal or None
                const yAnchor = this.genes.torsoSize.h / 2;
                this.genes.legAnchors = numLegs === 1 ? [{x: 0, y: yAnchor}] : [{ x: -this.genes.torsoSize.w / 2 + 5, y: yAnchor }, { x: this.genes.torsoSize.w / 2 - 5, y: yAnchor }];
            }
            for (let i = 0; i < numLegs; i++) {
                const leg = [];
                for (let j = 0; j < legSegments; j++) {
                    const len = evolveLegL ? 20 + Math.random() * 40 : 40;
                    const width = evolveLegW ? 5 + Math.random() * 10 : 10;
                    leg.push({ len, width, motorSpeed: Math.random() * 5, motorOffset: Math.random() * Math.PI, motorStrength: Math.random() * 0.5 });
                }
                this.genes.legs.push(leg);
            }
        }
    }
    crossover(p) {
        const nG = JSON.parse(JSON.stringify(this.genes));
        if (Math.random() < 0.5) nG.color = p.genes.color;
        if (Math.random() < 0.5) nG.torsoSize = p.genes.torsoSize;
        if (Math.random() < 0.5) nG.legAnchors = p.genes.legAnchors;

        for (let legIndex = 0; legIndex < numLegs; legIndex++) {
            for (let segIndex = 0; segIndex < legSegments; segIndex++) {
                const pSeg = p.genes.legs[legIndex]?.[segIndex];
                const cSeg = nG.legs[legIndex]?.[segIndex];
                if(pSeg && cSeg) {
                    if(Math.random()<0.5) cSeg.len = pSeg.len; if(Math.random()<0.5) cSeg.width = pSeg.width;
                    if(Math.random()<0.5) cSeg.motorSpeed = pSeg.motorSpeed; if(Math.random()<0.5) cSeg.motorOffset = pSeg.motorOffset;
                    if(Math.random()<0.5) cSeg.motorStrength = pSeg.motorStrength;
                }
            }
        }
        return new DNA(nG);
    }
    mutate(r) {
        const m = (v, d) => v + (Math.random() - 0.5) * d;
        if (evolveBodyW && Math.random() < r) this.genes.torsoSize.w = Math.max(10, m(this.genes.torsoSize.w, 10));
        if (evolveBodyH && Math.random() < r) this.genes.torsoSize.h = Math.max(10, m(this.genes.torsoSize.h, 10));
        this.genes.legAnchors.forEach(anchor => {
            if (Math.random() < r) anchor.x = m(anchor.x, 5); if (Math.random() < r) anchor.y = m(anchor.y, 5);
        });
        this.genes.legs.forEach(leg => {
            leg.forEach(segment => {
                if (evolveLegL && Math.random() < r) segment.len = Math.max(10, m(segment.len, 10));
                if (evolveLegW && Math.random() < r) segment.width = Math.max(5, m(segment.width, 5));
                if (Math.random() < r) segment.motorSpeed = m(segment.motorSpeed, 1);
                if (Math.random() < r) segment.motorOffset = m(segment.motorOffset, Math.PI / 2);
                if (Math.random() < r) segment.motorStrength = m(segment.motorStrength, 0.1);
            });
        });
        if (Math.random() < r) this.genes.color = `hsl(${Math.random() * 360}, 70%, 70%)`;
    }
}

function setup() {
    engine = Engine.create({ positionIterations: 4, velocityIterations: 2 }); 
    engine.world.gravity.y = gravity;
    render = Render.create({canvas:canvas,engine:engine,options:{width:SIM_WIDTH,height:SIM_HEIGHT,wireframes:false,background:'transparent'}});
    ground = Bodies.rectangle(SIM_WIDTH*2, SIM_HEIGHT-25, SIM_WIDTH*10, 50, {isStatic:true, friction: friction, render:{fillStyle:'#333'}});
    World.add(engine.world, [ground, ...createFlag(SPAWN_X, '#00dd00')]);
    Events.on(engine, 'beforeUpdate', () => { if (isRunning && !isPaused) population.forEach(walker => walker.update(engine.timing.timestamp / 1000)); });
    runner = Runner.create(); Runner.run(runner, engine); Render.run(render);
    nextGeneration();
}

function uiLoop() {
    if (isStarting || (!isRunning && !isPaused)) return;
    if(!isPaused) {
        updateDisplayAndCamera();
        const timeLeft = genTime - (performance.now() - generationTimer) / 1000;
        info_time.textContent = Math.max(0, timeLeft).toFixed(1);
        if (timeLeft <= 0) nextGeneration();
    }
    if (isRunning) uiTimer = requestAnimationFrame(uiLoop);
}

function updateDisplayAndCamera() {
    population.sort((a,b) => b.torso.position.x - a.torso.position.x);
    const topPerformers = new Set(population.slice(0, topNDisplay));
    population.forEach(w => w.render(topPerformers.has(w)?'normal':'hidden'));
    if (cameraToggleInput.checked && population.length > 0) cameraTargetX = population[0].torso.position.x;
    cameraX += (cameraTargetX - cameraX) * 0.05;
    Render.lookAt(render, {min:{x:cameraX - SIM_WIDTH/2, y:0}, max:{x:cameraX + SIM_WIDTH/2, y:SIM_HEIGHT}});
}

function nextGeneration() {
    isRunning = false;
    if(uiTimer) cancelAnimationFrame(uiTimer);

    population.forEach(w => {
        let distance = Math.max(0, w.torso.position.x - w.startPosition.x);
        const torsoAngle = w.torso.angle;

        if (locomotionGoal === 'bipedal') {
            const uprightAngleThreshold = Math.PI / 3;
            if (Math.abs(torsoAngle) > uprightAngleThreshold) distance *= 0.1;
        } else if (locomotionGoal === 'quadrupedal') {
            const horizontalAngleThreshold = Math.PI / 4;
            if (Math.abs(Math.abs(torsoAngle) - Math.PI/2) > horizontalAngleThreshold) distance *= 0.1;
        }
        w.fitness = distance;
    });

    population.sort((a, b) => b.fitness - a.fitness);
    const bestWalker = population.length > 0 ? population[0] : null;
    const bestDist = bestWalker ? bestWalker.fitness : 0;
    
    if (generation > 0) generationHistory.push({ generation: generation, distance: bestWalker ? Math.max(0, bestWalker.torso.position.x - bestWalker.startPosition.x) : 0 });
    if (bestDist > bestDistanceAllTime) bestDistanceAllTime = bestDist;
    if (generation > 0) { previousBest2 = {...previousBest1}; previousBest1 = {generation: generation, distance: bestDist}; }

    generation++; info_gen.textContent = generation; info_dist.textContent = bestDistanceAllTime.toFixed(2);
    updateHistoryUIAndFlags(); updateChart();
    
    const eliteCount = Math.floor(population.length * (matingPoolPercent / 100));
    const matingPool = [];
    if(bestDist > 0) {
        const elite = population.slice(0, Math.max(1, eliteCount));
        elite.forEach(w => { for(let i=0; i<100; i++) matingPool.push(w.dna); });
    }
    population.forEach(w => w.destroy()); population = [];

    const spawnPromises = [];
    for (let i = 0; i < popSize; i++) {
        const spawnPromise = new Promise(resolve => setTimeout(() => {
            if (isStarting) return resolve();
            const pA = matingPool.length > 0 ? matingPool[Math.floor(Math.random()*matingPool.length)] : new DNA();
            const pB = matingPool.length > 0 ? matingPool[Math.floor(Math.random()*matingPool.length)] : new DNA();
            const childDNA = pA.crossover(pB); childDNA.mutate(mutationRate);
            const spawnHeight = locomotionGoal === 'bipedal' ? SIM_HEIGHT - 250 : SIM_HEIGHT - 150;
            population.push(new Walker(childDNA, SPAWN_X, spawnHeight));
            resolve();
        }, i * (500 / popSize) ));
    }
    
    Promise.all(spawnPromises).then(() => { if (!isStarting) { isRunning = true; isPaused = false; generationTimer = performance.now(); uiTimer = requestAnimationFrame(uiLoop); }});
}

function createFlag(x, color) { const y = SIM_HEIGHT-50, opt={isStatic:true,isSensor:true,render:{fillStyle:color}}; return [Bodies.rectangle(x, y-20, 3, 40, opt), Bodies.rectangle(x+10, y-40, 20, 10, opt)]; }
function updateHistoryUIAndFlags() {
    if(historyFlag1.length>0)World.remove(engine.world,historyFlag1); if(historyFlag2.length>0)World.remove(engine.world,historyFlag2);
    historyFlag1=[],historyFlag2=[];
    if(previousBest1.generation>0){ history1DistEl.textContent=`${previousBest1.distance.toFixed(2)}m`;history1GenEl.textContent=previousBest1.generation; if(previousBest1.distance>0){historyFlag1=createFlag(SPAWN_X+previousBest1.distance,'#ffd700');World.add(engine.world,historyFlag1);}}else{history1DistEl.textContent="N/A";history1GenEl.textContent="0";}
    if(previousBest2.generation>0){ history2DistEl.textContent=`${previousBest2.distance.toFixed(2)}m`;history2GenEl.textContent=previousBest2.generation; if(previousBest2.distance>0){historyFlag2=createFlag(SPAWN_X+previousBest2.distance,'#00aaff');World.add(engine.world,historyFlag2);}}else{history2DistEl.textContent="N/A";history2GenEl.textContent="0";}
}

function setupChart() {
    const ctx = document.getElementById('evolutionChart').getContext('2d');
    evolutionChart = new Chart(ctx, {
        type: 'line', data: { labels: [], datasets: [{ label: 'Best Distance per Generation', data: [], borderColor: '#00aaff', backgroundColor: 'rgba(0, 170, 255, 0.2)', borderWidth: 2, fill: true, tension: 0.1 }] },
        options: { scales: { x: { title: { display: true, text: 'Generation', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} }, y: { title: { display: true, text: 'Distance (m)', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} } }, plugins: { legend: { labels: { color: '#ccc' } } }, responsive: true, }
    });
}
function updateChart() {
    if (!evolutionChart) return;
    evolutionChart.data.labels = generationHistory.map(h => h.generation);
    evolutionChart.data.datasets[0].data = generationHistory.map(h => h.distance);
    evolutionChart.update();
}

function readSettings() { 
    popSize = parseInt(popSizeInput.value); mutationRate = parseFloat(mutationRateInput.value)/100;
    topNDisplay = parseInt(topNDisplayInput.value); genTime = parseInt(genTimeInput.value);
    legSegments = Math.max(1,Math.min(3,parseInt(legJointsInput.value))); legJointsInput.value = legSegments;
    matingPoolPercent = parseInt(matingPoolInput.value); numLegs = parseInt(numLegsInput.value);
    gravity = parseFloat(gravityInput.value); friction = parseFloat(frictionInput.value);
    evolveBodyW = evolveBodyWidthToggle.checked; evolveBodyH = evolveBodyHeightToggle.checked;
    evolveLegL = evolveLegLengthToggle.checked; evolveLegW = evolveLegWidthToggle.checked;
    locomotionGoal = document.querySelector('input[name="locomotion"]:checked').value;
}

// --- Event Listeners ---
resetButton.addEventListener('click', () => {
    Object.entries(defaultSettings).forEach(([key, value]) => {
        if (key === 'locomotion') {
            document.querySelector(`input[name="locomotion"][value="${value}"]`).checked = true;
        } else {
            const input = document.getElementById(key);
            if (input.type === 'checkbox') input.checked = value;
            else input.value = value;
        }
    });
});

pauseButton.addEventListener('click', () => {
    if (!isRunning) return;
    isPaused = !isPaused;
    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
    if (!isPaused) {
        generationTimer += performance.now() - (window.pauseStartTime || 0);
        uiLoop();
    } else {
        window.pauseStartTime = performance.now();
    }
});

function stopSimulation() {
    isRunning = false;
    isPaused = false;
    if (uiTimer) cancelAnimationFrame(uiTimer);
    if (runner) Runner.stop(runner);
    if (render) Render.stop(render);
    if (engine) {
        World.clear(engine.world);
        Engine.clear(engine);
    }
}

startButton.addEventListener('click', () => {
    if (isStarting) return;
    
    isStarting = true;
    startButton.textContent = 'Starting...';
    startButton.disabled = true;
    pauseButton.disabled = true;
    pauseButton.textContent = 'Pause';

    stopSimulation();

    setTimeout(() => {
        readSettings();
        generation = 0; bestDistanceAllTime = 0; population = [];
        previousBest1 = { generation: 0, distance: 0 }; previousBest2 = { generation: 0, distance: 0 };
        generationHistory = []; cameraX = SPAWN_X; cameraTargetX = SPAWN_X;
        
        updateHistoryUIAndFlags();
        if (evolutionChart) {
            evolutionChart.data.labels = [];
            evolutionChart.data.datasets[0].data = [];
            evolutionChart.update();
        }

        setup();

        isStarting = false;
        startButton.textContent = 'Restart Evolution';
        startButton.disabled = false;
        pauseButton.disabled = false;
    }, 100);
});


// Initial Setup
storeDefaultSettings();
readSettings();
setupChart();
info_gen.textContent="0";info_dist.textContent="0.00";info_time.textContent=genTimeInput.value;
</script>
</body>
</html>