<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Walker Evolution Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body { font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background: #1a1a1a; color: #e0e0e0; padding-bottom: 5rem; }
        #main-container { max-width: 1200px; width: 100%; padding: 2rem; box-sizing: border-box; }
        #header { text-align: center; margin-bottom: 1rem; border-bottom: 1px solid #444; padding-bottom: 1rem; }
        h1 { color: #00aaff; margin-bottom: 0.5rem; }
        #header p { color: #b0b0b0; max-width: 800px; margin: 0 auto; line-height: 1.6; }
        .panel { border: 2px solid #444; background: linear-gradient(to bottom, #282c34, #1e2128); border-radius: 8px; overflow: hidden; }
        #simulation-area { position: relative; cursor: grab; margin-bottom: 1rem; }
        #simulation-area:active { cursor: grabbing; }
        .info-panel { position: absolute; top: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 6px; font-size: 14px; z-index: 10; }
        #info { left: 10px; }
        #history-info { right: 10px; text-align: right; }
        .history-entry { color: #ccc; }
        .history-entry span { color: #fff; font-weight: 600; }
        #import-status { text-align: center; color: #00ff88; height: 1em; margin-bottom: 1rem; font-weight: 600; }
        
        #controls-container { display: flex; flex-direction: column; gap: 1rem; }
        #main-actions { padding: 1rem; background-color: #2a2a2a; border-radius: 8px; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        #settings-panels { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1rem; }
        
        fieldset { border: 1px solid #444; border-radius: 8px; padding: 1rem; background-color: #2a2a2a; }
        legend { color: #00aaff; font-weight: 600; padding: 0 0.5rem; }
        
        .control-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; align-items: center; }
        .control-group { display: flex; flex-direction: column; align-items: center; cursor: help; text-align: center;}
        .toggle-group { display: flex; align-items: center; justify-content: center; gap: 8px; }
        .radio-group { display: flex; flex-direction: column; gap: 0.5rem; align-items: flex-start;}
        .full-width { grid-column: 1 / -1; }

        label { font-size: 0.9em; margin-bottom: 5px; color: #ccc; }
        input[type="number"] { width: 70px; text-align: center; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; }
        button, .button-label { font-size: 1em; font-weight: 600; padding: 10px 20px; border: none; border-radius: 5px; background: #00aaff; color: #fff; cursor: pointer; transition: background-color 0.2s, opacity 0.2s; display: inline-block; }
        button:hover, .button-label:hover { background: #0088cc; }
        button:disabled { background: #555; opacity: 0.5; cursor: not-allowed; }
        #pauseButton { background-color: #ffaa00; }
        #pauseButton:hover { background-color: #cc8800; }
        #resetButton { background-color: #dd5555; }
        #resetButton:hover { background-color: #bb3333; }
        #exportButton { background-color: #55dd55; }
        #exportButton:hover { background-color: #33bb33; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div id="main-container">
        <div id="header"><h1>AI Walker Evolution Simulator</h1><p>A population of simple "walkers" is created with random DNA. Their goal: travel as far as possible in a fixed time. The most successful walkers from each generation "breed" to create the next, passing on traits with slight mutations. Over time, they evolve effective ways to walk.</p></div>
        <div id="simulation-area" class="panel">
            <canvas id="world"></canvas>
            <div id="info" class="info-panel"><div>Generation: <span id="generation">0</span></div><div>All-Time Best: <span id="best-distance">0.00</span> m</div><div>Time Left: <span id="time-left">0</span> s</div></div>
            <div id="history-info" class="info-panel"><div class="history-entry">Last Gen Best: <span id="history-1-dist">N/A</span> (Gen <span id="history-1-gen">0</span>)</div><div class="history-entry">Prev Gen Best: <span id="history-2-dist">N/A</span> (Gen <span id="history-2-gen">0</span>)</div></div>
        </div>
        <div id="import-status"></div>
        <div id="controls-container">
            <div id="main-actions" class="panel">
                <button id="startButton">Start Evolution</button>
                <button id="pauseButton" disabled>Pause</button>
                <button id="resetButton">Reset Settings</button>
                <button id="exportButton" disabled>Export DNA</button>
                <label for="import-dna-file" class="button-label">Import DNA</label>
                <input type="file" id="import-dna-file" accept=".json" style="display: none;">
            </div>

            <div id="settings-panels">
                <fieldset>
                    <legend>Core Simulation</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The number of walkers created in each generation."><label for="popSize">Population</label><input type="number" id="popSize" value="100" min="10"></div>
                        <div class="control-group" title="The time each generation has to prove its fitness."><label for="genTime">Time per Gen (s)</label><input type="number" id="genTime" value="15" min="5"></div>
                        <div class="control-group" title="Percentage of the top walkers that breed. Lower values are more 'elitist'."><label for="matingPool">Mating Pool (%)</label><input type="number" id="matingPool" value="50" min="1" max="100"></div>
                        <div class="control-group" title="The friction of the ground."><label for="friction">Ground Friction</label><input type="number" id="friction" value="0.8" min="0.1" step="0.1"></div>
                        <div class="control-group" title="The strength of gravity."><label for="gravity">Gravity</label><input type="number" id="gravity" value="1.0" min="0.1" step="0.1"></div>
                        <div class="control-group" title="How many of the current top performers to display."><label for="topNDisplay">Show Top</label><input type="number" id="topNDisplay" value="10" min="1"></div>
                        <div class="toggle-group full-width" title="Toggle whether the camera automatically follows the current leader."><label for="cameraToggle">Auto-Camera</label><input type="checkbox" id="cameraToggle" checked></div>
                    </div>
                </fieldset>
                
                <fieldset>
                    <legend>Walker Anatomy & Genetics</legend>
                    <div class="control-grid">
                        <div class="control-group" title="The chance for any single gene to mutate."><label for="mutationRate">Mutation Rate (%)</label><input type="number" id="mutationRate" value="5" min="0"></div>
                        <div class="control-group" title="Number of legs on each walker."><label for="numLegs">Number of Legs</label><input type="number" id="numLegs" value="2" min="1" max="2"></div>
                        <div class="control-group full-width" title="Number of segments per leg. More segments allow for more complex movements."><label for="legJoints">Leg Segments (1-3)</label><input type="number" id="legJoints" value="2" min="1" max="3"></div>
                        
                        <div class="toggle-group"><label for="evolveBodyWidth">Evolve Body Width</label><input type="checkbox" id="evolveBodyWidth" checked></div>
                        <div class="toggle-group"><label for="evolveBodyHeight">Evolve Body Height</label><input type="checkbox" id="evolveBodyHeight" checked></div>
                        <div class="toggle-group"><label for="evolveLegLength">Evolve Leg Length</label><input type="checkbox" id="evolveLegLength" checked></div>
                        <div class="toggle-group"><label for="evolveLegWidth">Evolve Leg Width</label><input type="checkbox" id="evolveLegWidth" checked></div>
                        <div class="toggle-group"><label for="evolveLegAnchorX">Evolve Leg X-Pos</label><input type="checkbox" id="evolveLegAnchorX"></div>
                        <div class="toggle-group"><label for="evolveLegAnchorY">Evolve Leg Y-Pos</label><input type="checkbox" id="evolveLegAnchorY"></div>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Locomotion Goal</legend>
                     <div class="radio-group">
                        <div><label><input type="radio" name="locomotion" value="none"> None (Free Evolution)</label></div>
                        <div><label><input type="radio" name="locomotion" value="bipedal" checked> Bipedal (Penalize Falling)</label></div>
                        <div><label><input type="radio" name="locomotion" value="quadrupedal"> Quadrupedal (Penalize being upright)</label></div>
                    </div>
                </fieldset>
            </div>
        </div>

        <div id="chart-container" class="panel" style="margin-top: 2rem; padding: 1rem;">
            <canvas id="evolutionChart"></canvas>
        </div>
    </div>

<script>
const { Engine, Render, Runner, World, Bodies, Body, Constraint, Vector, Events, Composite } = Matter;

// Main elements
const canvas = document.getElementById('world');
const startButton = document.getElementById('startButton'), pauseButton = document.getElementById('pauseButton');
const resetButton = document.getElementById('resetButton'), exportButton = document.getElementById('exportButton');
const importDnaFile = document.getElementById('import-dna-file'), importStatus = document.getElementById('import-status');

// Info displays
const info_gen = document.getElementById('generation'), info_dist = document.getElementById('best-distance'), info_time = document.getElementById('time-left');
const history1DistEl = document.getElementById('history-1-dist'), history1GenEl = document.getElementById('history-1-gen');
const history2DistEl = document.getElementById('history-2-dist'), history2GenEl = document.getElementById('history-2-gen');

// --- Input elements ---
const popSizeInput = document.getElementById('popSize');
const genTimeInput = document.getElementById('genTime');
const topNDisplayInput = document.getElementById('topNDisplay');
const cameraToggleInput = document.getElementById('cameraToggle');
const frictionInput = document.getElementById('friction');
const gravityInput = document.getElementById('gravity'); // Correctly linked now
const mutationRateInput = document.getElementById('mutationRate');
const matingPoolInput = document.getElementById('matingPool');
const numLegsInput = document.getElementById('numLegs');
const legJointsInput = document.getElementById('legJoints');
const evolveBodyWidthToggle = document.getElementById('evolveBodyWidth');
const evolveBodyHeightToggle = document.getElementById('evolveBodyHeight');
const evolveLegLengthToggle = document.getElementById('evolveLegLength');
const evolveLegWidthToggle = document.getElementById('evolveLegWidth');
const evolveLegAnchorXToggle = document.getElementById('evolveLegAnchorX');
const evolveLegAnchorYToggle = document.getElementById('evolveLegAnchorY');

const SIM_WIDTH = 1200, SIM_HEIGHT = 600, SPAWN_X = 100;

// --- State variables ---
let popSize, mutationRate, topNDisplay, genTime, legSegments, matingPoolPercent, numLegs, gravity, friction;
let evolveBodyW, evolveBodyH, evolveLegL, evolveLegW, evolveLegAnchorX, evolveLegAnchorY, locomotionGoal;
let population = [], historyFlag1 = [], historyFlag2 = [];
let generation = 0, bestDistanceAllTime = 0;
let previousBest1 = { generation: 0, distance: 0 }, previousBest2 = { generation: 0, distance: 0 };
let runner = null, engine = null, render = null, ground = null; // Initialize as null to ensure proper re-creation
let generationTimer, uiTimer = null, isRunning = false, isStarting = false, isPaused = false;
let cameraTargetX = SPAWN_X, cameraX = SPAWN_X;
let isPanning = false, lastPanX = 0;
let evolutionChart, generationHistory = [];
let importedDnaPool = null;
let lastGenerationMatingPool = [];

const defaultSettings = {};
function storeDefaultSettings() {
    document.querySelectorAll('#settings-panels input').forEach(input => {
        const key = input.type === 'radio' ? input.name : input.id;
        if (input.type === 'radio') {
            if (input.checked) defaultSettings[key] = input.value;
        } else {
            defaultSettings[key] = input.type === 'checkbox' ? input.checked : input.value;
        }
    });
}

class Walker {
    constructor(dna, x, y) {
        // console.log(`[Walker.constructor] Creating walker at (${x}, ${y}) with DNA:`, dna);
        this.dna = dna;
        const group = -1; // Collide with nothing in the same group
        const bodyRenderStyle = { strokeStyle: '#333', lineWidth: 2 };
        const opt = { friction: 0.8, collisionFilter: { group }, render: bodyRenderStyle };
        this.composite = Composite.create({ label: 'Walker' });

        // Torso creation with robust validation and clamping
        const torsoW = Math.max(10, Math.min(200, dna.genes.torsoSize.w || 40));
        const torsoH = Math.max(10, Math.min(200, dna.genes.torsoSize.h || 60));
        
        const torso = Bodies.rectangle(x, y, torsoW, torsoH, {...opt, render: { ...bodyRenderStyle, fillStyle: dna.genes.color }});
        this.torso = torso;
        this.startPosition = Vector.clone(torso.position);
        Composite.addBody(this.composite, torso);
        // console.log(`[Walker.constructor] Torso created: w=${torsoW}, h=${torsoH}`);

        dna.genes.legs.forEach((legDna, legIndex) => {
            let parentBody = this.torso;
            // Get anchor point from DNA, or use a sane default if somehow missing
            const rawAnchor = dna.genes.legAnchors[legIndex] || { x: 0, y: torsoH / 2 };
            
            // Clamp anchor points relative to torso dimensions (with a small margin)
            const parentAttachPoint = { 
                x: Math.max(-torsoW/2 + 5, Math.min(torsoW/2 - 5, rawAnchor.x)),
                y: Math.max(-torsoH/2 + 5, Math.min(torsoH/2 - 5, rawAnchor.y)) 
            };
            // console.log(`[Walker.constructor] Leg ${legIndex} anchor:`, parentAttachPoint);

            legDna.forEach((segmentDna, segIndex) => {
                // Ensure leg segment sizes are valid and clamped
                const legWidth = Math.max(5, Math.min(30, segmentDna.width || 10));
                const legLength = Math.max(10, Math.min(100, segmentDna.len || 40));

                // Calculate segment spawn position relative to the parent body's current position and attachment point
                // For the first segment, parentBody is the torso. For subsequent, it's the previous segment.
                // Matter.js positions bodies by their center.
                const currentParentPos = parentBody.position;
                // We want to attach the top of the current segment to the attachment point on the parent.
                // So, the segment's center will be at parentAttachPoint.y + legLength/2 from parent's center.
                const spawnX = currentParentPos.x + parentAttachPoint.x; 
                const spawnY = currentParentPos.y + parentAttachPoint.y + legLength / 2; 

                const segmentBody = Bodies.rectangle(spawnX, spawnY, legWidth, legLength, {...opt, render: { ...bodyRenderStyle, fillStyle: '#888' }});
                
                const joint = Constraint.create({
                    bodyA: parentBody, 
                    bodyB: segmentBody,
                    pointA: parentAttachPoint, // Point on parent relative to its center
                    pointB: { x: 0, y: -legLength / 2 }, // Point on child (segment) relative to its center (its top)
                    stiffness: 0.9, 
                    length: 0, 
                    render: { visible: false }
                });

                Composite.addBody(this.composite, segmentBody);
                Composite.addConstraint(this.composite, joint);
                
                parentBody = segmentBody; // The newly created segment becomes the parent for the next segment in this leg
                parentAttachPoint = { x: 0, y: legLength / 2 }; // The attachment point is now the bottom center of the new parent segment
                // console.log(`[Walker.constructor]   Leg ${legIndex}, Segment ${segIndex} created. Pos: (${spawnX.toFixed(0)}, ${spawnY.toFixed(0)})`);
            });
        });
        World.add(engine.world, this.composite);
        // console.log(`[Walker.constructor] Walker composite added to world. Current bodies in Matter.js world: ${engine.world.bodies.length}`);
    }
    update(simTime) {
        // Ensure there are actual legs/segments before trying to animate
        if (!this.dna.genes.legs || this.dna.genes.legs.length === 0) return;

        const allSegmentsDna = this.dna.genes.legs.flat();
        // The first body in composite is torso, subsequent are leg segments
        const legSegmentBodies = this.composite.bodies.slice(1); 
        legSegmentBodies.forEach((segmentBody, index) => {
            const segmentDna = allSegmentsDna[index];
            if (segmentDna) {
                Body.setAngularVelocity(segmentBody, Math.sin(simTime * segmentDna.motorSpeed + segmentDna.motorOffset) * segmentDna.motorStrength);
            }
        });
    }
    render(style) { const v = style !== 'hidden'; Composite.allBodies(this.composite).forEach(p => p.render.visible = v); }
    destroy() { World.remove(engine.world, this.composite); }
}

class DNA {
    constructor(genes) {
        if (genes) {
            this.genes = genes;
        } else {
            this.genes = { legs: [], color: `hsl(${Math.random() * 360}, 70%, 70%)` };
            
            // Torso Size with sensible defaults and clamping
            const baseW = (locomotionGoal === 'quadrupedal') ? 60 : 40; // Default torso widths
            const baseH = (locomotionGoal === 'quadrupedal') ? 40 : 60; // Default torso heights
            const randW = evolveBodyW ? (Math.random() - 0.5) * 60 : 0; // Random +/- 30
            const randH = evolveBodyH ? (Math.random() - 0.5) * 60 : 0; // Random +/- 30
            
            this.genes.torsoSize = { 
                w: Math.max(20, Math.min(150, baseW + randW)), 
                h: Math.max(20, Math.min(150, baseH + randH))
            };
            
            this.genes.legAnchors = [];
            const torsoHalfW = this.genes.torsoSize.w / 2;
            const torsoHalfH = this.genes.torsoSize.h / 2;

            for (let i = 0; i < numLegs; i++) {
                let baseAnchorX, baseAnchorY;
                
                // Determine base anchor point based on locomotion goal and number of legs
                // These are robust defaults before randomness/mutation
                if (numLegs === 1) {
                    baseAnchorX = 0;
                } else { // 2 legs
                    baseAnchorX = (i === 0) ? -torsoHalfW * 0.5 : torsoHalfW * 0.5; 
                }
                
                if (locomotionGoal === 'quadrupedal') {
                    baseAnchorY = torsoHalfH * 0.8; // Towards bottom, but not fully for quadrupedal
                } else { // Bipedal or None
                    baseAnchorY = torsoHalfH; // At the very bottom for bipedal
                }
                
                // Add random offset if evolution is enabled for anchors, clamp within reasonable range
                const initialAnchorRangeX = 30; // Max initial random offset for X
                const initialAnchorRangeY = 20; // Max initial random offset for Y

                let anchorX = evolveLegAnchorX ? baseAnchorX + (Math.random() - 0.5) * initialAnchorRangeX : baseAnchorX;
                let anchorY = evolveLegAnchorY ? baseAnchorY + (Math.random() - 0.5) * initialAnchorRangeY : baseAnchorY;

                // Clamp anchor points to ensure they are always within the torso's bounds (with a small margin)
                anchorX = Math.max(-torsoHalfW + 5, Math.min(torsoHalfW - 5, anchorX));
                anchorY = Math.max(-torsoHalfH + 5, Math.min(torsoHalfH - 5, anchorY));

                this.genes.legAnchors.push({ x: anchorX, y: anchorY });
            }

            // Create leg segments
            for (let i = 0; i < numLegs; i++) {
                const leg = [];
                for (let j = 0; j < legSegments; j++) {
                    // Leg segment dimensions with sensible defaults and clamping
                    const len = evolveLegL ? Math.max(10, Math.min(80, 20 + (Math.random() - 0.5) * 40)) : 40; // Default 40, +/- 20
                    const width = evolveLegW ? Math.max(5, Math.min(20, 5 + (Math.random() - 0.5) * 10)) : 10; // Default 10, +/- 5
                    
                    leg.push({ 
                        len, 
                        width, 
                        motorSpeed: Math.random() * 5, 
                        motorOffset: Math.random() * Math.PI, 
                        motorStrength: Math.random() * 0.5 
                    });
                }
                this.genes.legs.push(leg);
            }
            // console.log("New DNA genes created:", this.genes);
        }
    }
    crossover(p) {
        const nG = JSON.parse(JSON.stringify(this.genes));
        if (Math.random() < 0.5) nG.color = p.genes.color;
        if (Math.random() < 0.5) nG.torsoSize = p.genes.torsoSize;
        
        // Crossover leg anchors: Iterating per leg, swap if random condition met
        for (let i = 0; i < numLegs; i++) {
            if (p.genes.legAnchors[i] && Math.random() < 0.5) { 
                nG.legAnchors[i] = { ...p.genes.legAnchors[i] };
            }
        }

        for (let legIndex = 0; legIndex < numLegs; legIndex++) {
            for (let segIndex = 0; segIndex < legSegments; segIndex++) {
                const pSeg = p.genes.legs[legIndex]?.[segIndex];
                const cSeg = nG.legs[legIndex]?.[segIndex];
                if(pSeg && cSeg) {
                    if(Math.random()<0.5) cSeg.len = pSeg.len; if(Math.random()<0.5) cSeg.width = pSeg.width;
                    if(Math.random()<0.5) cSeg.motorSpeed = pSeg.motorSpeed; if(Math.random()<0.5) cSeg.motorOffset = pSeg.motorOffset;
                    if(Math.random()<0.5) cSeg.motorStrength = pSeg.motorStrength;
                }
            }
        }
        return new DNA(nG);
    }
    mutate(r) {
        const m = (v, d) => v + (Math.random() - 0.5) * d;
        
        // Torso mutation with bounds
        if (evolveBodyW && Math.random() < r) this.genes.torsoSize.w = Math.max(20, Math.min(150, m(this.genes.torsoSize.w, 15)));
        if (evolveBodyH && Math.random() < r) this.genes.torsoSize.h = Math.max(20, Math.min(150, m(this.genes.torsoSize.h, 15)));
        
        this.genes.legAnchors.forEach(anchor => {
            const torsoHalfW = this.genes.torsoSize.w / 2;
            const torsoHalfH = this.genes.torsoSize.h / 2;
            
            // Mutate X anchor if enabled, clamp within torso bounds
            if (evolveLegAnchorX && Math.random() < r) {
                anchor.x = Math.max(-torsoHalfW + 5, Math.min(torsoHalfW - 5, m(anchor.x, 10)));
            }
            // Mutate Y anchor if enabled, clamp within torso bounds
            if (evolveLegAnchorY && Math.random() < r) {
                anchor.y = Math.max(-torsoHalfH + 5, Math.min(torsoHalfH - 5, m(anchor.y, 8)));
            }
        });

        this.genes.legs.forEach(leg => {
            leg.forEach(segment => {
                if (evolveLegL && Math.random() < r) segment.len = Math.max(10, Math.min(80, m(segment.len, 10)));
                if (evolveLegW && Math.random() < r) segment.width = Math.max(5, Math.min(20, m(segment.width, 5)));
                if (Math.random() < r) segment.motorSpeed = m(segment.motorSpeed, 1);
                if (Math.random() < r) segment.motorOffset = m(segment.motorOffset, Math.PI / 2);
                if (Math.random() < r) segment.motorStrength = m(segment.motorStrength, 0.1);
            });
        });
        if (Math.random() < r) this.genes.color = `hsl(${Math.random() * 360}, 70%, 70%)`;
    }
}

function setup() {
    console.log("-> setup() called. Initializing Matter.js engine and renderer...");
    
    // Ensure existing engine, render, runner are stopped and nullified before creating new ones
    if (engine) stopSimulation(); 

    engine = Engine.create({ positionIterations: 4, velocityIterations: 2 }); 
    engine.world.gravity.y = gravity;
    
    // Validate gravity
    if (isNaN(engine.world.gravity.y) || !isFinite(engine.world.gravity.y)) {
        console.error("Invalid gravity value:", gravity, ". Setting to default 1.0.");
        engine.world.gravity.y = 1.0;
    }

    render = Render.create({
        canvas: canvas,
        engine: engine,
        options: {
            width: SIM_WIDTH,
            height: SIM_HEIGHT,
            wireframes: false, // Ensure wireframes are off for colored bodies
            background: 'transparent'
        }
    });
    Render.run(render); // Start the renderer AFTER creating it
    
    runner = Runner.create(); // Create runner AFTER engine
    Runner.run(runner, engine); // Start the runner AFTER creating it and engine

    ground = Bodies.rectangle(SIM_WIDTH*2, SIM_HEIGHT-25, SIM_WIDTH*10, 50, {isStatic:true, friction: friction, render:{fillStyle:'#333'}});
    World.add(engine.world, [ground, ...createFlag(SPAWN_X, '#00dd00')]);
    console.log(`-> Ground and initial flag added to world. Current bodies in Matter.js world: ${engine.world.bodies.length}`);

    Events.on(engine, 'beforeUpdate', () => { 
        if (isRunning && !isPaused) {
            population.forEach(walker => walker.update(engine.timing.timestamp / 1000)); 
        }
    });
    
    console.log("-> Matter.js Engine, Runner, and Renderer are running.");
    nextGeneration(); // Start the first generation
}

function uiLoop() {
    if (isStarting || (!isRunning && !isPaused)) return;
    if(!isPaused) {
        updateDisplayAndCamera();
        const timeLeft = genTime - (performance.now() - generationTimer) / 1000;
        info_time.textContent = Math.max(0, timeLeft).toFixed(1);
        if (timeLeft <= 0) nextGeneration();
    }
    uiTimer = requestAnimationFrame(uiLoop); // Always request next frame if not starting/stopped
}

function updateDisplayAndCamera() {
    if (!render || !render.engine || !render.engine.world || population.length === 0) {
        // console.warn("updateDisplayAndCamera: Renderer or population not ready.");
        return; 
    }
    population.sort((a,b) => b.torso.position.x - a.torso.position.x);
    const topPerformers = new Set(population.slice(0, topNDisplay));
    population.forEach(w => w.render(topPerformers.has(w)?'normal':'hidden'));
    if (cameraToggleInput.checked && population.length > 0) cameraTargetX = population[0].torso.position.x;
    cameraX += (cameraTargetX - cameraX) * 0.05;
    Render.lookAt(render, {min:{x:cameraX - SIM_WIDTH/2, y:0}, max:{x:cameraX + SIM_WIDTH/2, y:SIM_HEIGHT}});
}

function nextGeneration() {
    console.log(`--- Starting Generation ${generation + 1} ---`);
    isRunning = false; // Pause simulation logic while calculating and spawning
    if(uiTimer) cancelAnimationFrame(uiTimer);

    // 1. Calculate fitness for the *current (just finished)* population
    population.forEach(w => {
        let distance = Math.max(0, w.torso.position.x - w.startPosition.x);
        const torsoAngle = w.torso.angle;

        if (locomotionGoal === 'bipedal') {
            const uprightAngleThreshold = Math.PI / 3;
            if (Math.abs(torsoAngle) > uprightAngleThreshold) distance *= 0.1;
        } else if (locomotionGoal === 'quadrupedal') {
            const horizontalAngleThreshold = Math.PI / 4;
            if (Math.abs(Math.abs(torsoAngle) - Math.PI/2) > horizontalAngleThreshold) distance *= 0.1;
        }
        w.fitness = distance;
    });

    // 2. Sort the *current (just finished)* population by fitness
    population.sort((a, b) => b.fitness - a.fitness);
    
    const bestWalker = population.length > 0 ? population[0] : null;
    const bestDist = bestWalker ? bestWalker.fitness : 0;
    
    // Store the mating pool from THIS completed generation for export and next breeding
    lastGenerationMatingPool = [];
    const eliteCountForExport = Math.floor(population.length * (matingPoolPercent / 100));
    if(population.length > 0 && population[0].fitness > 0) { 
        const eliteForExport = population.slice(0, Math.max(1, eliteCountForExport));
        eliteForExport.forEach(w => { 
            for(let i=0; i<100; i++) lastGenerationMatingPool.push(w.dna); 
        });
    }
    console.log(`Generation ${generation} fitness calculated. Best dist: ${bestDist.toFixed(2)}m. Mating pool size for export: ${lastGenerationMatingPool.length}`);

    if (generation > 0) generationHistory.push({ generation: generation, distance: bestWalker ? Math.max(0, bestWalker.torso.position.x - bestWalker.startPosition.x) : 0 });
    if (bestDist > bestDistanceAllTime) bestDistanceAllTime = bestDist;
    if (generation > 0) { previousBest2 = {...previousBest1}; previousBest1 = {generation: generation, distance: bestDist}; }

    generation++; info_gen.textContent = generation; info_dist.textContent = bestDistanceAllTime.toFixed(2);
    updateHistoryUIAndFlags(); updateChart();
    
    let matingPoolForBreeding;
    if (generation === 1 && importedDnaPool) {
        matingPoolForBreeding = importedDnaPool;
        importedDnaPool = null;
        importStatus.textContent = '';
        console.log("Using imported DNA for breeding pool (Gen 1).");
    } else {
        matingPoolForBreeding = lastGenerationMatingPool;
        console.log("Using previous generation's mating pool for breeding.");
    }

    // Destroy old walkers from the Matter.js world
    population.forEach(w => w.destroy()); 
    population = []; // Clear population array
    
    const spawnPromises = [];
    for (let i = 0; i < popSize; i++) {
        spawnPromises.push(new Promise(resolve => {
            setTimeout(() => {
                if (isStarting) return resolve(); // Exit if simulation is being reset/stopped
                try {
                    const pA = matingPoolForBreeding.length > 0 ? matingPoolForBreeding[Math.floor(Math.random()*matingPoolForBreeding.length)] : new DNA();
                    const pB = matingPoolForBreeding.length > 0 ? matingPoolForBreeding[Math.floor(Math.random()*matingPoolForBreeding.length)] : new DNA();
                    const childDNA = pA.crossover(pB); childDNA.mutate(mutationRate);
                    
                    const spawnHeight = locomotionGoal === 'bipedal' ? SIM_HEIGHT - 250 : SIM_HEIGHT - 150;
                    population.push(new Walker(childDNA, SPAWN_X, spawnHeight));
                    // console.log(`[nextGeneration] Spawned Walker ${i + 1}/${popSize}`);
                } catch (e) {
                    console.error(`[nextGeneration] Error spawning walker ${i + 1}:`, e);
                }
                resolve();
            }, i * (500 / popSize) ); // Stagger spawn to prevent browser freeze on many bodies
        }));
    }
    
    Promise.all(spawnPromises).then(() => { 
        if (!isStarting) { 
            isRunning = true; 
            isPaused = false; 
            generationTimer = performance.now(); 
            uiTimer = requestAnimationFrame(uiLoop); 
            console.log(`[nextGeneration] All ${popSize} walkers spawned. Simulation running.`);
        } else {
            console.log("[nextGeneration] Spawn sequence interrupted by start/reset. Not starting simulation loop.");
        }
    }).catch(e => {
        console.error("[nextGeneration] Error during walker spawning promise resolution:", e);
    });
}

function createFlag(x, color) { const y = SIM_HEIGHT-50, opt={isStatic:true,isSensor:true,render:{fillStyle:color}}; return [Bodies.rectangle(x, y-20, 3, 40, opt), Bodies.rectangle(x+10, y-40, 20, 10, opt)]; }
function updateHistoryUIAndFlags() {
    // Check if engine exists before trying to remove/add bodies
    if (!engine || !engine.world) return;

    if(historyFlag1.length>0)World.remove(engine.world,historyFlag1); 
    if(historyFlag2.length>0)World.remove(engine.world,historyFlag2);
    
    historyFlag1=[],historyFlag2=[]; // Clear array references
    
    if(previousBest1.generation>0){ 
        history1DistEl.textContent=`${previousBest1.distance.toFixed(2)}m`;
        history1GenEl.textContent=previousBest1.generation; 
        if(previousBest1.distance>0){
            historyFlag1=createFlag(SPAWN_X+previousBest1.distance,'#ffd700');
            World.add(engine.world,historyFlag1);
        }
    }else{
        history1DistEl.textContent="N/A";
        history1GenEl.textContent="0";
    }

    if(previousBest2.generation>0){ 
        history2DistEl.textContent=`${previousBest2.distance.toFixed(2)}m`;
        history2GenEl.textContent=previousBest2.generation; 
        if(previousBest2.distance>0){
            historyFlag2=createFlag(SPAWN_X+previousBest2.distance,'#00aaff');
            World.add(engine.world,historyFlag2);
        }
    }else{
        history2DistEl.textContent="N/A";
        history2GenEl.textContent="0";
    }
}

function setupChart() {
    const ctx = document.getElementById('evolutionChart').getContext('2d');
    if (evolutionChart) { // Destroy existing chart if it exists to prevent conflicts
        evolutionChart.destroy();
    }
    evolutionChart = new Chart(ctx, {
        type: 'line', data: { labels: [], datasets: [{ label: 'Best Distance per Generation', data: [], borderColor: '#00aaff', backgroundColor: 'rgba(0, 170, 255, 0.2)', borderWidth: 2, fill: true, tension: 0.1 }] },
        options: { scales: { x: { title: { display: true, text: 'Generation', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} }, y: { title: { display: true, text: 'Distance (m)', color: '#ccc'}, grid: { color: 'rgba(204, 204, 204, 0.2)' }, ticks: { color: '#ccc'} } }, plugins: { legend: { labels: { color: '#ccc' } } }, responsive: true, }
    });
}
function updateChart() {
    if (!evolutionChart) return;
    evolutionChart.data.labels = generationHistory.map(h => h.generation);
    evolutionChart.data.datasets[0].data = generationHistory.map(h => h.distance);
    evolutionChart.update();
}

function readSettings() { 
    popSize = parseInt(popSizeInput.value) || 100; 
    mutationRate = parseFloat(mutationRateInput.value)/100 || 0.05;
    topNDisplay = parseInt(topNDisplayInput.value) || 10;
    genTime = parseInt(genTimeInput.value) || 15;
    legSegments = Math.max(1,Math.min(3,parseInt(legJointsInput.value) || 2)); 
    legJointsInput.value = legSegments; // Update input field to clamped value
    matingPoolPercent = parseInt(matingPoolInput.value) || 50;
    numLegs = parseInt(numLegsInput.value) || 2;
    gravity = parseFloat(gravityInput.value) || 1.0;
    friction = parseFloat(frictionInput.value) || 0.8;
    evolveBodyW = evolveBodyWidthToggle.checked; 
    evolveBodyH = evolveBodyHeightToggle.checked;
    evolveLegL = evolveLegLengthToggle.checked; 
    evolveLegW = evolveLegWidthToggle.checked;
    evolveLegAnchorX = evolveLegAnchorXToggle.checked; 
    evolveLegAnchorY = evolveLegAnchorYToggle.checked; 
    locomotionGoal = document.querySelector('input[name="locomotion"]:checked').value;
    console.log("Settings read:", {popSize, mutationRate, genTime, numLegs, legSegments, gravity, friction, evolveLegAnchorX, evolveLegAnchorY, locomotionGoal});
}

// --- Event Listeners ---
resetButton.addEventListener('click', () => {
    Object.entries(defaultSettings).forEach(([key, value]) => {
        if (key === 'locomotion') {
            const radio = document.querySelector(`input[name="locomotion"][value="${value}"]`);
            if (radio) radio.checked = true;
        } else {
            const input = document.getElementById(key);
            if (input) {
                if (input.type === 'checkbox') input.checked = value;
                else input.value = value;
            }
        }
    });
    readSettings(); // Re-read settings after reset to apply them
    console.log("Settings reset to defaults.");
});

pauseButton.addEventListener('click', () => {
    if (!isRunning) return;
    isPaused = !isPaused;
    pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
    console.log(`Simulation ${isPaused ? 'paused' : 'resumed'}.`);
    if (!isPaused) {
        generationTimer += performance.now() - (window.pauseStartTime || 0); // Adjust timer for pause duration
        uiLoop(); // Resume UI and simulation loop
    } else {
        window.pauseStartTime = performance.now(); // Record pause start time
    }
});

function stopSimulation() {
    console.log("Stopping simulation components.");
    isRunning = false; 
    isPaused = false;
    if (uiTimer) {
        cancelAnimationFrame(uiTimer);
        uiTimer = null;
    }
    
    if (runner) { 
        Runner.stop(runner); 
        runner = null; 
    }
    if (render) { 
        Render.stop(render); 
        render.canvas.remove(); // Remove old canvas to prevent memory leaks/multiple canvases
        render = null; 
        // Re-add a new canvas element if it was removed. This is often safer than just nulling render.
        // For simplicity, we assume canvas is always there by HTML and just clear its context.
        // If your setup removes/re-adds canvas, adjust this.
        canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
    }
    if (engine) { 
        World.clear(engine.world); 
        Engine.clear(engine); 
        engine = null; 
    }
    // Explicitly clear canvas content visually
    const ctx = canvas.getContext('2d');
    if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    console.log("Simulation components stopped and nullified.");
}

startButton.addEventListener('click', () => {
    if (isStarting) return; // Prevent multiple clicks during startup
    console.log("Start Evolution button clicked. Initiating sequence.");
    isStarting = true;
    startButton.textContent = 'Starting...'; 
    startButton.disabled = true;
    pauseButton.disabled = true; 
    pauseButton.textContent = 'Pause';
    exportButton.disabled = true;
    
    stopSimulation(); // Ensure previous simulation is cleanly stopped and components nulled
    
    // Small delay to ensure browser has time to cleanup/render before new setup begins
    setTimeout(() => {
        readSettings(); // Read current settings from UI fields
        // Reset global simulation state variables for a new run
        generation = 0; 
        bestDistanceAllTime = 0; 
        population = [];
        previousBest1 = { generation: 0, distance: 0 }; 
        previousBest2 = { generation: 0, distance: 0 };
        generationHistory = []; 
        cameraX = SPAWN_X; 
        cameraTargetX = SPAWN_X;
        lastGenerationMatingPool = []; 
        
        updateHistoryUIAndFlags(); // Clear history flags
        setupChart(); // Re-initialize chart
        
        setup(); // Calls Matter.js setup and starts first generation
        
        isStarting = false; // Allow button to be clicked again
        startButton.textContent = 'Restart Evolution'; 
        startButton.disabled = false;
        pauseButton.disabled = false; 
        exportButton.disabled = false;
        console.log("Simulation setup complete and running.");
    }, 100);
});

exportButton.addEventListener('click', () => {
    if (!lastGenerationMatingPool || lastGenerationMatingPool.length === 0) {
        alert("No successful walkers (i.e., none moved forward) to export yet. Let at least one generation complete and achieve some distance.");
        return;
    }
    const dnaJson = JSON.stringify(lastGenerationMatingPool, null, 2); 
    const blob = new Blob([dnaJson], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `walker_dna_gen_${generation - 1}.json`; 
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log(`Exported DNA from generation ${generation - 1}.`);
});

importDnaFile.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const importedData = JSON.parse(e.target.result);
            if (Array.isArray(importedData) && importedData.length > 0 && importedData[0] && importedData[0].genes) {
                importedDnaPool = importedData;
                importStatus.textContent = `DNA from "${file.name}" imported successfully! Click Start to use it.`;
                console.log(`Successfully imported DNA from "${file.name}".`);
            } else {
                throw new Error("Invalid DNA file format. Expected an array of DNA objects with 'genes'.");
            }
        } catch (error) {
            alert(`Error reading file: ${error.message}`);
            importedDnaPool = null;
            importStatus.textContent = ''; 
            console.error(`Failed to import DNA from "${file.name}":`, error);
        }
    };
    reader.readAsText(file);
    importDnaFile.value = ''; // Reset file input to allow re-importing the same file
});

// Initial Setup when page loads
storeDefaultSettings();
readSettings(); // Read initial settings for setup()
setupChart();
info_gen.textContent="0";
info_dist.textContent="0.00";
info_time.textContent=genTimeInput.value; // Show initial generation time
console.log("Initial page load: Default settings stored, UI updated.");

</script>
</body>
</html>
